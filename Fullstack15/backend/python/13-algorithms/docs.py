# ✅1. Nested loops
# ✅2. Recursion
# ✅3. Linear search
# ✅4. Binary search
# ✅5. Bubble sort
# =============================================================================
# =============================================================================
# =============================================================================
# ✅1. NESTED loops
import time
# ------------------------------------------------------------------
# Time complexity
#     --- Time that is required to execute the function
#     RU: Время, необходимое для выполнения функции

# Memory usage
#     --- RAM --> Random Access Memory
#     RU: Оперативная память
# ------------------------------------------------------------------
# O(1)  ->  Одинаковое время выполнения функции
# def test():
#     return 1 + 1
# ------------------------------------------------------------------
# O(n)  ->  Время выполнения функции зависит от аргумента
# def test(n):
#     return 1 + n

# ------------------------------------------------------------------
# O(n) * O(n) = O(n^2)
# def myFunc(n):
#     for i in range(n):
#         # 10 times
#         for i2 in range(n):
#             # 10 * 10 === 100 times
#             print(i2)
# myFunc(10)
# =============================================================================
# ALGORITHMS BASED ON NESTED LOOPS
# RU: АЛГОРИТМЫ НА ОСНОВЕ ВЛОЖЕННЫХ ЦИКЛОВ
# 1. Two pointers
from typing import List
def removeDuplicates(nums: List[int]) -> int:
    # INPUT  ==>>  user information
    # Input: nums = [0,0,1,1,1,2,2,3,3,4]
    # Output: 5, nums = [0, 1, 2, 3, 4, _, _, _, _, _]
    j = 0
    for i in range(1, len(nums)):
        if nums[j] != nums[i]:
            j += 1
            nums[j] = nums[i]
        # j==0, i==1   =>   0 != 0   =>  False
        # j==0, i==2   =>   0 != 1   =>  True    =>   j==>1  ===>>  [0,1 ...]
        # j==1, i==3   =>   1 != 1   =>  False
        # j==1, i==4   =>   1 != 1   =>  False
        # j==1, i==5   =>   1 != 2   =>  True    =>   j==>2  ===>>  [0,1,2 ...]
        # ...
    return j + 1
# =============================================================================
# =============================================================================
# =============================================================================
# =============================================================================
# =============================================================================
# ✅2. Recursion
def count_up(max_num: int, counter:int=1) -> None:
    print(counter)
    if max_num > counter:
        return count_up(max_num, counter+1)
count_up(10)


def count_down(max_num:int) -> None:
    print(max_num)
    if max_num > 1:
        count_down(max_num-1)
count_down(10)

